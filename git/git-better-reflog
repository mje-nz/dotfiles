#!/usr/bin/env zsh
# Massage the output from git reflog into a more helpful format:
# * Display the index-format reflog designator (master@{0}) but also the
#   timestamp from the timestamp-format reflog designator (master@{1 minute ago}).
# * Use descriptive commit names in reflog statuses.
# * Include commit status, author and date if they aren't in the reflog status.
#
# Author: Matthew Edwards

# Enable PCRE for ".*?"
emulate -L zsh
setopt RE_MATCH_PCRE
# Make "local" work in loops
setopt TYPESET_SILENT

# Use colour if stdout is a tty
if [[ -t 1 ]]; then
	color="--color"
	dim="$(tput dim)"
	reset="$(tput sgr0)"
fi

# Pretty reflog command prefixed with bare commit hash
main_reflog() {
	git reflog "$color" "--format=%h %Cred%gd%C(auto): %h %gs" "$1@{0}"
}
# Second reflog command to get timestamp-format designator and commit info
extra_reflog() {
	git reflog "$color" "--format=%h %gd %s (%C(blue)%an%C(yellow), %C(green)%cr%C(white))" "$1@{now}"
}
# Regexes for parsing output
main_regex='(\w+) (.*?@{\d+}.*?): (.+)'
extra_regex='(\w+) .*?@{(.*?)} (.*) (\(.*\))'
moving_regex='(.*? moving from) (.*?) to (.*)'
rebase_regex='(rebase -i \(finish\):) (.*?) onto (.*)'

# Look up descriptive name for revision
declare -A rev_names
get_name() {
	local rev=$1 output=$2
	if (( ${+rev_names[$rev]} == 0 )); then
		rev_names[$rev]="$(git name-rev --exclude="remotes/*" --name-only --no-undefined --always "$rev" 2> /dev/null)"
		rev_names[$rev]="${rev_names[$rev]#tags/}"
	fi
	eval "$output=\"${rev_names[$rev]}\""
}

# Basically the git pager
pager() {
	if [[ -t 1 ]]; then
		eval "$(git var GIT_PAGER)"
	else
		cat
	fi
}

# Read from both reflog commands line-by-line and combine them
main() {
	local ref_length
	while read -r main <&3 && read -r extra <&4; do
		[[ "$main" =~ $main_regex ]] || return 255
		# shellcheck disable=SC2154
		local commit="${match[1]}" ref="${match[2]}" body="${match[3]}"
		[[ "$extra" =~ $extra_regex ]] || return 254
		local extra_commit="${match[1]}" extra_time="${match[2]}"
		local extra_status="${match[3]}" extra_info="${match[4]}"
		[[ "$commit" == "$extra_commit" ]] || return 253

		if [[ "$body" =~ $moving_regex ]]; then
			# Abbreviate commits in "moving from x to y" messages
			local start="${match[1]}" ref1="${match[2]}" ref2="${match[3]}"
			local end="${match[4]}"
			get_name "$ref1" new_ref1 || return 252
			get_name "$ref2" new_ref2 || return 251
			# shellcheck disable=SC2154
			body="$start $new_ref1 to $new_ref2 $end"
		fi

		if [[ "$body" =~ $rebase_regex ]]; then
			# Abbreviate commits in "rebase -i (finish): x onto y" messages
			local start="${match[1]}" ref1="${match[2]}" ref2="${match[3]}"
			get_name "$ref1" new_ref1 || return 252
			get_name "$ref2" new_ref2 || return 251
			# shellcheck disable=SC2154
			body="$start $new_ref1 onto $new_ref2"
		fi

		if [[ "$body" != *"$extra_status" ]]; then
			# Print commit status when it isn't in the reflog status
			body="$body ${dim}[$extra_status $extra_info]$reset"
		fi


		if [[ -z "$ref_length" ]]; then
			if [[ $(git rev-list --count --walk-reflogs HEAD) -ge 10 ]]; then
				# If there are ten or more reflog entries, pad designator field
				# to one longer than the first one we see so HEAD@{0} lines up
				# with HEAD@{10}
		 		(( ref_length = ${#ref} + 1 ))
		 	else
		 		ref_length=${#ref}
		 	fi
		fi

		printf "%-*s %-15s %s\n" "$ref_length" "$ref" "($extra_time):" "$body"
	done 3< <(main_reflog "$1") 4< <(extra_reflog "$1")
}

if [[ $# -gt 1 || "$1" == *@* ]]; then
	echo "usage: git better-reflog [branch]" >&2
	exit 1
fi

main "$1" | pager
