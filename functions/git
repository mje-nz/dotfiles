#!/usr/bin/env zsh
# Print a warning message about git branch, turn on --recurse-submodules for clone
# and checkout.
#
# Author: Matthew Edwards

_print_and_run () {
  echo "$(tput dim)Running \"$*\" instead, use --no-recurse-submodules to prevent this.$(tput sgr0)"
  command "$@"
}

# Print a message if there are stashes on the current branch
_check_for_stashes () {
  local branch
  if branch="$(git symbolic-ref -q --short HEAD 2> /dev/null)" && [[ -n "$branch" ]]; then
    local stashes
    stashes="$(git stash list | grep "[Oo]n $branch")"
    if [[ -n "$stashes" ]]; then
      echo
      echo "You have stashed changes on this branch:"
      echo "$stashes"
    fi
  fi
}

# https://stackoverflow.com/a/39357426
git () {
  # "git branch <branch name>" with no other arguments
  if [[ "$1" == "branch" && "$#" == 2 && "$2" != "-"* ]]; then
    echo "'git branch' does not change branch! Did you mean 'git switch $2'?"
    command git "$@"
  # git clone
  elif [[ "$1" == "clone" ]]; then
    # shellcheck disable=SC2199
    if [[ ${@[(ie)--no-recurse-submodules]} -gt ${#@} ]]; then
      # Unless --no-recurse-submodules is provided, use --recurse-submodules:
      # After the clone is created, initialize and clone submodules.  This is
      # equivalent to running `git submodule update --init --recursive` immediately
      # after the clone is finished.
      shift 1
      _print_and_run git clone --recurse-submodules "$@"
    else
      command git "$@"
    fi
  # git checkout
  elif [[ "$1" == "checkout" || "$1" == "co" ]]; then
    shift 1
    # shellcheck disable=SC2199
    if [[ ${@[(ie)--no-recurse-submodules]} -gt ${#@} ]]; then
      # Unless --no-recurse-submodules is provided, use --recurse-submodules:
      # Update the content of all initialized submodules according to the commit
      # recorded in the superproject.  If local modifications in a submodule would
      # be overwritten the checkout will fail unless -f is used.
      _print_and_run git checkout --recurse-submodules "$@" || return $?
    else
      command git checkout "$@" || return $?
    fi
    _check_for_stashes
  # git stash list
  elif [[ "$1" == "stash" && "$2" == "list" ]]; then
    shift 2
    # TODO: check for --format in args first
    # Show date in stash list.
    # https://stackoverflow.com/a/31687960
    command git stash list --format="%gd (%cr): %gs" "$@"
  # git switch
  elif [[ "$1" == "switch" ]]; then
    # shellcheck disable=SC2199
    if [[ ${@[(ie)--no-recurse-submodules]} -gt ${#@} ]]; then
      # Unless --no-recurse-submodules is provided, use --recurse-submodules:
      # Update the content of all initialized submodules according to the commit
      # recorded in the superproject.  If nothing (or --no-recurse-submodules)
      # is used, the work trees of submodules will not be updated.  Just like
      # git-submodule(1), this will detach HEAD of the submodules.
      shift 1
      _print_and_run git switch --recurse-submodules "$@" || return $?
    else
      command git "$@" || return $?
    fi
    _check_for_stashes
  # Any other subcommand
  else
    command git "$@"
  fi
}

git "$@"
